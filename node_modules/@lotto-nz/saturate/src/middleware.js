import isPlainObject from 'lodash.isplainobject';

import CALL_API from './CALL_API';
import { isRSAA, validateRSAA } from './validation';
import { InvalidActionError, RequestError, ApiError, TimeoutError } from './errors' ;
import { getJSON, normalizeTypeDescriptors, actionWith } from './util';
import axios from 'axios'

/**
 * A Redux middleware that processes RSAA actions.
 *
 * @type {ReduxMiddleware}
 * @access public
 */
function apiMiddleware({ getState }) {
  return (next) => async (action) => {

    // Do not process actions without a [CALL_API] property
    if (!isRSAA(action)) {
      return next(action);
    }

    // Try to dispatch an error request FSA for invalid RSAAs
    const validationErrors = validateRSAA(action);
    if (validationErrors.length) {
      const callAPI = action[CALL_API];
      if (callAPI.types && Array.isArray(callAPI.types)) {
        let requestType = callAPI.types[0];
        if (requestType && requestType.type) {
          requestType = requestType.type;
        }
        next({
          type: requestType,
          payload: new InvalidActionError(validationErrors),
          error: true
        });
      }
      return;
    }

    // Parse the validated RSAA action
    const callAPI = action[CALL_API];
    var { endpoint, headers, timeout } = callAPI;
    const { method, body, credentials, bailout, types } = callAPI;
    const [requestType, successType, failureType] = normalizeTypeDescriptors(types);

    // Should we bail out?
    try {
      if (typeof bailout === 'boolean' && bailout) {
          return
      }
      else if (typeof bailout === 'function' && await bailout(getState()) === true) {
          return;
      }

    } catch (e) {
      if (typeof bailout === 'function' && bailout(getState())) {
        return;
      }

      return next(await actionWith(
        requestType,
        [action, getState(), new RequestError('[CALL_API].bailout function failed')]
      ));
    }

    // Process [CALL_API].endpoint function
    if (typeof endpoint === 'function') {
      try {
        endpoint = endpoint(getState());
      } catch (e) {
          return next(await actionWith(
            failureType,
            [action, getState(), new RequestError('[CALL_API].endpoint function failed')]
          ));
      }
    }

    // Process [CALL_API].headers function
    if (typeof headers === 'function') {
      try {
        headers = headers(getState());
      } catch (e) {
          return next(await actionWith(
            failureType,
            [action, getState(), new RequestError('[CALL_API].headers function failed')]
          ));
      }
    }

    // We can now dispatch the request FSA
    next(await actionWith(
      requestType,
      [action, getState()]
    ));

    try {

    if (typeof window === 'undefined' && process.env.NODE_ENV === 'production' && endpoint.indexOf('http') === -1) {
        endpoint = endpoint.replace('//', 'http://')
    }

      // Make the API callAPI
      var t
      var res
      var config = {
          url: endpoint,
          method,
          data: body,
          withCredentials: credentials,
          headers: headers || {},
          timeout: timeout || 0
      }

      if (timeout) {
          t = setTimeout(async () => {
              failureType.meta = action
              return next(await actionWith(
                  failureType,
                  [action, getState(), new TimeoutError(`Request exceeded timeout of ${timeout} msec`)]
              ))
          }, timeout)
      }

      res = await axios(config)

    } catch(e) {

        if (e.hasOwnProperty('status') && e.status === 451) {
          return next(await actionWith(
            { type: 'TERMS_CONDITIONS_ACTIVATE_MODAL', meta: action },
            [action, getState(), res]
          ));
        }
        else if (e.hasOwnProperty('data') && e.data.hasOwnProperty('message') && e.data.message.toString().indexOf('InvalidSessionException') > -1) {
          // the request was an invalid session exception
          return next(await actionWith(
            { type: 'ACTIVATE_INVALID_SESSION_MODAL', meta: action },
            [action, getState(), res]
          ));
        }
        else {
          // The request was malformed
          return next(await actionWith(
            {
                type: failureType.type || failureType,
                meta: action,
                payload: failureType.payload || e
            },
            [action, getState(), e]
          ));
        }
    }

    // Process the server response
    if (t) {
      clearTimeout(t)
    }

    if (res.status === 200) {
      return next(await actionWith(
        successType,
        [action, getState(), res]
      ));
    } else {
      return next(await actionWith(
        { type: failureType.type || failureType, meta: action },
        [action, getState(), res]
      ));
    }
  }
}

exports.version = '0.1.0'
export default apiMiddleware
